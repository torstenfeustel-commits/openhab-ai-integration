[{"id":"openhab_smart_home","user_id":"230637f6-d8de-490f-8567-aa6ff543974a","name":"OpenHAB Smart Home en","content":"\"\"\"\ntitle: OpenHAB Smart Home Tool\nauthor: Torsten Feustel\nfunding_url: https://github.com/torfeu/openhab-ai-integration\nversion: 0.3.4\nrequired_open_webui_version: 0.3.9\n\nOpenHAB Smart Home Integration with Enhanced Error Handling\n\"\"\"\n\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, Dict, Any, List, Set\nimport requests\nimport json\nimport re\nfrom collections import defaultdict\nimport time\nimport logging\n\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass OpenHABHelper:\n    \"\"\"\n    Helper class for OpenHAB operations with improved error handling\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        port: str,\n        api_token: str = \"\",\n        cache_ttl: int = 3600,\n        filter_enabled: bool = True,\n        filtered_types: List[str] = None,\n    ):\n        self.host = host\n        self.port = port\n        self.api_token = api_token\n        self.cache_ttl = cache_ttl\n        self.vocabulary_cache = None\n        self.vocabulary_last_update = None\n        self.search_index = None\n        self.filter_enabled = filter_enabled\n        self.filtered_types = filtered_types or []\n        self.last_load_error = None\n        self.last_successful_load = None\n\n    def get_base_url(self) -> str:\n        \"\"\"Create OpenHAB Base URL\"\"\"\n        return f\"http://{self.host}:{self.port}/rest\"\n\n    def get_headers(self) -> Dict[str, str]:\n        \"\"\"HTTP Headers for OpenHAB API\"\"\"\n        headers = {\"Accept\": \"application/json\"}\n        if self.api_token:\n            headers[\"Authorization\"] = f\"Bearer {self.api_token}\"\n        return headers\n\n    def should_filter_item(self, item: Dict[str, Any]) -> bool:\n        \"\"\"Check if an item should be filtered\"\"\"\n        if not self.filter_enabled:\n            return False\n        item_type = item.get(\"type\", \"\")\n        return item_type in self.filtered_types\n\n    def is_controllable_item(self, item: Dict[str, Any]) -> bool:\n        \"\"\"Uses OpenHAB's readOnly flag for precise detection\"\"\"\n        state_description = item.get(\"stateDescription\", {})\n        read_only = state_description.get(\"readOnly\", False)\n\n        if read_only:\n            return False\n\n        item_type = item.get(\"type\", \"\")\n        never_controllable = {\"DateTime\", \"Location\"}\n\n        if item_type in never_controllable:\n            return False\n\n        if item_type == \"Group\":\n            return False\n\n        return True\n\n    def get_possible_commands(self, item: Dict[str, Any]) -> List[str]:\n        \"\"\"Derives possible commands from item type\"\"\"\n        if not self.is_controllable_item(item):\n            return []\n\n        item_type = item.get(\"type\", \"\")\n\n        command_mapping = {\n            \"Switch\": [\"on\", \"off\", \"toggle\"],\n            \"Dimmer\": [\"on\", \"off\", \"0-100%\"],\n            \"Color\": [\"on\", \"off\", \"color\", \"brightness\"],\n            \"Rollershutter\": [\"up\", \"down\", \"0-100%\"],\n            \"Number:Temperature\": [\"15-30°C\"],\n            \"Number:Dimensionless\": [\"0-100\"],\n            \"Number:ElectricCurrent\": [\"current value\"],\n            \"Number:Power\": [\"power value\"],\n            \"Number:Energy\": [\"energy value\"],\n            \"Number:Pressure\": [\"pressure value\"],\n            \"Number:Humidity\": [\"humidity value\"],\n            \"Number\": [\"numeric value\"],\n            \"Player\": [\"play\", \"pause\", \"stop\"],\n            \"String\": [\"text\"],\n            \"Contact\": [\"status\"],\n        }\n\n        if \"Number:\" in item_type and item_type not in command_mapping:\n            return [\"numeric value\"]\n\n        return command_mapping.get(item_type, [\"command\"])\n\n    def get_control_status_text(self, item: Dict[str, Any]) -> str:\n        \"\"\"Creates controllability text for output without emojis\"\"\"\n        if self.is_controllable_item(item):\n            commands = self.get_possible_commands(item)\n            return f\"Controllable: {', '.join(commands)}\"\n        else:\n            return \"Status only (not controllable)\"\n\n    def load_openhab_items(self, force_reload: bool = False) -> List[Dict[str, Any]]:\n        \"\"\"\n        Loads all OpenHAB items with improved error handling\n\n        Args:\n            force_reload: Forces reload even if cache is still valid\n\n        Returns:\n            List of items or empty list on error (with error logging)\n        \"\"\"\n        try:\n            response = requests.get(\n                f\"{self.get_base_url()}/items\", headers=self.get_headers(), timeout=15\n            )\n\n            if response.status_code == 200:\n                all_items = response.json()\n\n                # Validation: Check if response is meaningful\n                if not isinstance(all_items, list):\n                    error_msg = (\n                        f\"Invalid response: Expected list, received {type(all_items)}\"\n                    )\n                    logger.error(error_msg)\n                    self.last_load_error = error_msg\n                    return []\n\n                if len(all_items) == 0:\n                    logger.warning(\"OpenHAB returned 0 items - possibly a problem\")\n                    self.last_load_error = \"No items received from OpenHAB\"\n                    return []\n\n                # Apply filter\n                if self.filter_enabled:\n                    filtered_items = [\n                        item for item in all_items if not self.should_filter_item(item)\n                    ]\n                    logger.info(\n                        f\"Filter active: {len(all_items)} items -> {len(filtered_items)} items \"\n                        f\"(filtered: {self.filtered_types})\"\n                    )\n                    all_items = filtered_items\n                else:\n                    logger.info(f\"Filter disabled: {len(all_items)} items loaded\")\n\n                # Successful load\n                self.last_successful_load = time.time()\n                self.last_load_error = None\n                return all_items\n\n            else:\n                error_msg = (\n                    f\"OpenHAB API error {response.status_code}: {response.text[:200]}\"\n                )\n                logger.error(error_msg)\n                self.last_load_error = error_msg\n                return []\n\n        except requests.exceptions.Timeout:\n            error_msg = f\"Timeout connecting to OpenHAB ({self.host}:{self.port})\"\n            logger.error(error_msg)\n            self.last_load_error = error_msg\n            return []\n\n        except requests.exceptions.ConnectionError:\n            error_msg = f\"Connection error to OpenHAB ({self.host}:{self.port})\"\n            logger.error(error_msg)\n            self.last_load_error = error_msg\n            return []\n\n        except json.JSONDecodeError:\n            error_msg = \"OpenHAB returned invalid JSON\"\n            logger.error(error_msg)\n            self.last_load_error = error_msg\n            return []\n\n        except Exception as e:\n            error_msg = f\"Unexpected error loading items: {str(e)}\"\n            logger.error(error_msg)\n            self.last_load_error = error_msg\n            return []\n\n    def extract_vocabulary(self, items_list: List[Dict[str, Any]]) -> Set[str]:\n        \"\"\"Automatically extracts keywords ONLY from active (non-filtered) items\"\"\"\n        vocabulary = set()\n\n        for item in items_list:\n            if self.should_filter_item(item):\n                continue\n\n            name = item.get(\"name\", \"\")\n            if name:\n                name_parts = name.lower().split(\"_\")\n                valid_parts = [\n                    part for part in name_parts if len(part) > 2 and not part.isdigit()\n                ]\n                vocabulary.update(valid_parts)\n\n            label = item.get(\"label\", \"\")\n            if label:\n                words = re.split(r\"[^a-zA-ZäöüÄÖÜßß]+\", label.lower())\n                valid_words = [word for word in words if len(word) > 2]\n                vocabulary.update(valid_words)\n\n            state = str(item.get(\"state\", \"\")).upper()\n            if state in [\"ON\", \"OFF\", \"OPEN\", \"CLOSED\", \"NULL\", \"UNDEF\"]:\n                vocabulary.add(state.lower())\n\n            category = item.get(\"category\", \"\")\n            if category and len(category) > 2:\n                vocabulary.add(category.lower())\n\n            tags = item.get(\"tags\", [])\n            for tag in tags:\n                if isinstance(tag, str) and len(tag) > 2:\n                    vocabulary.add(tag.lower())\n\n        cleaned_vocabulary = set()\n        for word in vocabulary:\n            if len(word) > 2 and not word.isdigit():\n                cleaned_vocabulary.add(word)\n\n        return cleaned_vocabulary\n\n    def build_search_index(self, items_list: List[Dict[str, Any]]):\n        \"\"\"Creates an index for fast searching\"\"\"\n        self.search_index = defaultdict(list)\n\n        for item in items_list:\n            if self.should_filter_item(item):\n                continue\n\n            name = item.get(\"name\", \"\").lower()\n            name_parts = name.split(\"_\")\n            for part in name_parts:\n                if len(part) > 2:\n                    self.search_index[part].append(item)\n\n            label = item.get(\"label\", \"\").lower()\n            if label:\n                words = re.split(r\"[^a-zA-ZäöüÄÖÜßß]+\", label)\n                for word in words:\n                    if len(word) > 2:\n                        self.search_index[word].append(item)\n\n            category = item.get(\"category\", \"\").lower()\n            if category:\n                self.search_index[category].append(item)\n\n            for tag in item.get(\"tags\", []):\n                if isinstance(tag, str):\n                    self.search_index[tag.lower()].append(item)\n\n    def check_items_changed(self, items: List[Dict[str, Any]]) -> bool:\n        \"\"\"\n        Checks if items have changed since last load (based on lastStateChange)\n        NEW FUNCTION for Smart Cache Invalidation\n        \"\"\"\n        if not items:\n            return False\n\n        # Collect all lastStateChange timestamps\n        max_state_change = 0\n        for item in items:\n            last_change = item.get(\"lastStateChange\", 0)\n            if isinstance(last_change, (int, float)) and last_change > max_state_change:\n                max_state_change = last_change\n\n        # If we have an old max_state_change, compare\n        if hasattr(self, \"last_items_max_state_change\"):\n            if max_state_change > self.last_items_max_state_change:\n                logger.info(\n                    f\"Items have changed! (max_state_change: {self.last_items_max_state_change} -> {max_state_change})\"\n                )\n                return True\n\n        # Save the current max_state_change\n        self.last_items_max_state_change = max_state_change\n        return False\n\n    def get_vocabulary(self, force_reload: bool = False) -> Set[str]:\n        \"\"\"Returns the current vocabulary with intelligent smart caching based on item changes\"\"\"\n        now = time.time()\n\n        # NEW LOGIC: Smart Cache Invalidation\n        # 1. Check if cache has expired time-wise\n        cache_age = None\n        if self.vocabulary_last_update is not None:\n            cache_age = now - self.vocabulary_last_update\n\n        # 2. Load items to check if they have changed\n        if (\n            not force_reload\n            and self.vocabulary_cache is not None\n            and cache_age is not None\n        ):\n            # Quick validation check\n            temp_items = self.load_openhab_items(force_reload=False)\n\n            if temp_items:\n                # Check if items have changed\n                items_changed = self.check_items_changed(temp_items)\n\n                if not items_changed and cache_age <= self.cache_ttl:\n                    logger.debug(\n                        f\"Cache valid ({cache_age:.1f}s old, limit: {self.cache_ttl}s) and items unchanged\"\n                    )\n                    return self.vocabulary_cache\n\n                if items_changed:\n                    logger.warning(\n                        f\"Cache invalidated! Items have changed - reload required\"\n                    )\n                    force_reload = True\n                elif cache_age > self.cache_ttl:\n                    logger.info(\n                        f\"Cache expired ({cache_age:.1f}s > {self.cache_ttl}s) - reloading\"\n                    )\n                    force_reload = True\n\n        # 3. Reload if necessary\n        logger.info(\"Reloading items...\")\n        items = self.load_openhab_items(force_reload=True)\n\n        # NEW LOGIC: Error handling when items cannot be loaded\n        if not items and self.vocabulary_cache is not None:\n            logger.warning(\"Items could not be loaded, using old cache\")\n            return self.vocabulary_cache\n        elif not items:\n            logger.error(\"Items could not be loaded and no cache available!\")\n            return set()\n\n        # Save items and update cache\n        self.check_items_changed(items)  # Save max_state_change\n        self.vocabulary_cache = self.extract_vocabulary(items)\n        self.vocabulary_last_update = now\n        self.build_search_index(items)\n\n        logger.info(f\"Vocabulary updated: {len(self.vocabulary_cache)} words\")\n        return self.vocabulary_cache\n\n    def normalize_umlauts(self, word: str) -> str:\n        \"\"\"Normalizes German umlauts for OpenHAB compatibility\"\"\"\n        umlaut_map = {\n            \"ä\": \"ae\",\n            \"ö\": \"oe\",\n            \"ü\": \"ue\",\n            \"Ä\": \"AE\",\n            \"Ö\": \"OE\",\n            \"Ü\": \"UE\",\n            \"ß\": \"ss\",\n        }\n\n        normalized = word\n        for umlaut, replacement in umlaut_map.items():\n            normalized = normalized.replace(umlaut, replacement)\n\n        return normalized\n\n    def search_items_and(self, query_words: List[str]) -> List[Dict[str, Any]]:\n        \"\"\"AND search: Items must contain ALL query words\"\"\"\n        if not self.search_index:\n            return []\n\n        query_words_lower = [word.lower() for word in query_words]\n\n        item_sets = []\n        for word in query_words_lower:\n            if word in self.search_index:\n                item_set = set()\n                for item in self.search_index[word]:\n                    if not self.should_filter_item(item):\n                        item_set.add(item[\"name\"])\n                item_sets.append(item_set)\n            else:\n                return []\n\n        if not item_sets:\n            return []\n\n        common_items = item_sets[0]\n        for item_set in item_sets[1:]:\n            common_items = common_items.intersection(item_set)\n\n        results = []\n        for word in query_words_lower:\n            for item in self.search_index[word]:\n                if item[\"name\"] in common_items and not self.should_filter_item(item):\n                    if not any(r[\"name\"] == item[\"name\"] for r in results):\n                        item_copy = item.copy()\n                        item_copy[\"match_score\"] = len(query_words)\n                        results.append(item_copy)\n\n        return results\n\n    def search_items_or(self, query_words: List[str]) -> List[Dict[str, Any]]:\n        \"\"\"OR search: Items must contain at least ONE query word\"\"\"\n        if not self.search_index:\n            return []\n\n        query_words_lower = [word.lower() for word in query_words]\n        results_dict = {}\n\n        for word in query_words_lower:\n            if word in self.search_index:\n                for item in self.search_index[word]:\n                    if self.should_filter_item(item):\n                        continue\n\n                    item_name = item[\"name\"]\n                    if item_name not in results_dict:\n                        item_copy = item.copy()\n                        item_copy[\"match_score\"] = 1\n                        item_copy[\"matched_words\"] = [word]\n                        results_dict[item_name] = item_copy\n                    else:\n                        if word not in results_dict[item_name][\"matched_words\"]:\n                            results_dict[item_name][\"match_score\"] += 1\n                            results_dict[item_name][\"matched_words\"].append(word)\n\n        results = list(results_dict.values())\n        results.sort(key=lambda x: x[\"match_score\"], reverse=True)\n        return results\n\n    def validate_query(\n        self, query_words: List[str], search_mode: str = \"and\"\n    ) -> Dict[str, Any]:\n        \"\"\"Validates the search query against the vocabulary\"\"\"\n        if not query_words:\n            return {\"valid\": False, \"error\": \"Empty search query\"}\n\n        if len(query_words) > 10:\n            return {\"valid\": False, \"error\": \"Too many search terms (max 10)\"}\n\n        vocabulary = self.get_vocabulary()\n\n        if not vocabulary:\n            return {\n                \"valid\": False,\n                \"error\": f\"Vocabulary could not be loaded: {self.last_load_error}\",\n                \"complete_vocabulary\": [],\n            }\n\n        valid_words = [w for w in query_words if w.lower() in vocabulary]\n        invalid_words = [w for w in query_words if w.lower() not in vocabulary]\n\n        if invalid_words:\n            vocabulary_list = sorted(list(vocabulary))\n\n            if search_mode.lower() == \"and\":\n                error_msg = f\"AND search stopped!\\n\\nInvalid keywords: {', '.join(invalid_words)}\\n\\nAND search requires ALL terms in the vocabulary.\"\n            else:\n                error_msg = f\"Invalid keywords found: {', '.join(invalid_words)}\"\n\n            error_msg += (\n                f\"\\n\\nPlease use only these {len(vocabulary_list)} available keywords:\"\n            )\n\n            return {\n                \"valid\": False,\n                \"error\": error_msg,\n                \"invalid_words\": invalid_words,\n                \"valid_words\": valid_words,\n                \"complete_vocabulary\": vocabulary_list,\n                \"recommend_vocabulary_check\": True,\n            }\n\n        if not valid_words:\n            vocabulary_list = sorted(list(vocabulary))\n            return {\n                \"valid\": False,\n                \"error\": \"No valid search terms found\",\n                \"complete_vocabulary\": vocabulary_list,\n                \"recommend_vocabulary_check\": True,\n            }\n\n        return {\n            \"valid\": True,\n            \"valid_words\": valid_words,\n            \"invalid_words\": invalid_words,\n        }\n\n    def format_search_results(\n        self, results: List[Dict[str, Any]], mode: str, max_results: int = 50\n    ) -> str:\n        \"\"\"Formats search results WITH controllability information without emojis\"\"\"\n        # if not results:\n        #    return \"No results found. Tip: Check vocabulary with get_vocabulary_list()\"\n\n        if not results:\n            msg = \"No results found.\"\n            if mode.lower() == \"and\":\n                msg += \"\\n\\nTip: AND mode requires ALL terms to match. Try 'or' mode for broader results.\"\n            msg += \"\\nUse get_vocabulary_list() to see all available keywords.\"\n            return msg\n\n        filter_info = \"\"\n        if self.filter_enabled and self.filtered_types:\n            filter_info = f\" | Filter: {', '.join(self.filtered_types)} excluded\"\n\n        controllable_count = sum(\n            1 for item in results if self.is_controllable_item(item)\n        )\n        readonly_count = len(results) - controllable_count\n\n        output = (\n            f\"Search results ({mode.upper()} mode, {len(results)} found{filter_info})\\n\"\n        )\n        output += (\n            f\"{controllable_count} controllable | {readonly_count} status only\\n\\n\"\n        )\n\n        for item in results[:max_results]:\n            name = item.get(\"name\", \"Unknown\")\n            label = item.get(\"label\", name)\n            state = item.get(\"state\", \"N/A\")\n            item_type = item.get(\"type\", \"Unknown\")\n            match_score = item.get(\"match_score\", 0)\n\n            control_indicator = (\n                \"[CONTROLLABLE]\" if self.is_controllable_item(item) else \"[STATUS]\"\n            )\n\n            state_str = str(state)\n            state_str = re.sub(r\"(\\d+\\.\\d{2})\\d+\", r\"\\1\", state_str)\n\n            output += f\"{control_indicator} {label} ({item_type}) | {state_str} | Score: {match_score}\\n\"\n            output += f\"   {name}\\n\"\n\n        if len(results) > max_results:\n            hidden = len(results) - max_results\n            output += f\"... and {hidden} more results\\n\"\n\n        return output\n\n    def send_command(self, device_name: str, command: str) -> bool:\n        \"\"\"Sends command to OpenHAB device\"\"\"\n        try:\n            headers = self.get_headers()\n            headers[\"Content-Type\"] = \"text/plain\"\n\n            command_mapping = {\n                \"ein\": \"ON\",\n                \"an\": \"ON\",\n                \"on\": \"ON\",\n                \"aus\": \"OFF\",\n                \"off\": \"OFF\",\n                \"toggle\": \"TOGGLE\",\n                \"umschalten\": \"TOGGLE\",\n                \"hoch\": \"UP\",\n                \"up\": \"UP\",\n                \"runter\": \"DOWN\",\n                \"down\": \"DOWN\",\n            }\n\n            mapped_command = command_mapping.get(command.lower(), command)\n\n            response = requests.post(\n                f\"{self.get_base_url()}/items/{device_name}\",\n                data=mapped_command,\n                headers=headers,\n                timeout=10,\n            )\n\n            return response.status_code in [200, 202]\n\n        except Exception as e:\n            logger.error(f\"Error sending command: {e}\")\n            return False\n\n\nclass Tools:\n    class Valves(BaseModel):\n        openhab_host: str = Field(\n            default=\"192.168.1.100\", description=\"OpenHAB server IP address\"\n        )\n        openhab_port: str = Field(default=\"8080\", description=\"OpenHAB server port\")\n        openhab_api_token: str = Field(\n            default=\"\", description=\"OpenHAB API token (optional)\"\n        )\n        max_search_results: int = Field(\n            default=50, description=\"Maximum number of search results\"\n        )\n        cache_ttl: int = Field(\n            default=3600, description=\"Vocabulary cache TTL in seconds\"\n        )\n        enable_item_filter: bool = Field(\n            default=True, description=\"Enable item type filter\"\n        )\n        filter_group_items: bool = Field(\n            default=True, description=\"Filter out group items\"\n        )\n        custom_filtered_types: str = Field(\n            default=\"\", description=\"Additional item types to filter (comma-separated)\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.helper = None\n\n    def _get_filtered_types(self) -> List[str]:\n        \"\"\"Creates list of item types to filter\"\"\"\n        filtered_types = []\n\n        if self.valves.filter_group_items:\n            filtered_types.append(\"Group\")\n\n        if self.valves.custom_filtered_types:\n            custom_types = [\n                t.strip() for t in self.valves.custom_filtered_types.split(\",\")\n            ]\n            filtered_types.extend(custom_types)\n\n        return filtered_types\n\n    def _get_helper(self) -> OpenHABHelper:\n        \"\"\"Creates helper instance as needed\"\"\"\n        filtered_types = self._get_filtered_types()\n\n        if (\n            self.helper is None\n            or self.helper.host != self.valves.openhab_host\n            or self.helper.port != self.valves.openhab_port\n            or self.helper.api_token != self.valves.openhab_api_token\n            or self.helper.cache_ttl != self.valves.cache_ttl\n            or self.helper.filter_enabled != self.valves.enable_item_filter\n            or self.helper.filtered_types != filtered_types\n        ):\n\n            self.helper = OpenHABHelper(\n                host=self.valves.openhab_host,\n                port=self.valves.openhab_port,\n                api_token=self.valves.openhab_api_token,\n                cache_ttl=self.valves.cache_ttl,\n                filter_enabled=self.valves.enable_item_filter,\n                filtered_types=filtered_types,\n            )\n        return self.helper\n\n    def search_openhab_items(self, query_words: List[str], mode: str = \"and\") -> str:\n        \"\"\"\n        Main search function for OpenHAB items with controllability info\n\n        Args:\n            query_words: List of search terms from the vocabulary\n            mode: \"and\" for precise search, \"or\" for broad search\n\n        Returns:\n            str: Formatted search results with controllability information\n        \"\"\"\n        start_time = time.time()\n        helper = self._get_helper()\n\n        normalized_words = []\n        umlaut_changes = []\n\n        for word in query_words:\n            normalized = helper.normalize_umlauts(word)\n            normalized_words.append(normalized)\n\n            if normalized != word:\n                umlaut_changes.append(f\"'{word}' → '{normalized}'\")\n\n        validation = helper.validate_query(normalized_words, mode)\n        if not validation[\"valid\"]:\n            error_msg = validation[\"error\"]\n\n            if \"complete_vocabulary\" in validation:\n                vocabulary_list = validation[\"complete_vocabulary\"]\n                error_msg += f\"\\n\\n**All {len(vocabulary_list)} available keywords:**\\n\"\n                error_msg += \", \".join(vocabulary_list)\n                return error_msg\n\n            return error_msg\n\n        valid_words = validation[\"valid_words\"]\n\n        if mode.lower() == \"and\":\n            results = helper.search_items_and(valid_words)\n        else:\n            results = helper.search_items_or(valid_words)\n\n        search_time = round((time.time() - start_time) * 1000, 1)\n\n        output = \"\"\n\n        if umlaut_changes:\n            output += f\"Umlaut normalization: {', '.join(umlaut_changes)}\\n\"\n\n        output += f\"Search: {', '.join(valid_words)} ({mode.upper()} mode)\\n\"\n        output += f\"Time: {search_time}ms\\n\\n\"\n        output += helper.format_search_results(\n            results, mode, self.valves.max_search_results\n        )\n\n        return output\n\n    def control_openhab_device(self, device_name: str, command: str) -> str:\n        \"\"\"Controls an OpenHAB device\"\"\"\n        helper = self._get_helper()\n        success = helper.send_command(device_name, command)\n\n        if success:\n            return f\"[SUCCESS] {device_name} successfully set to '{command}'!\"\n        else:\n            return f\"[ERROR] Control of '{device_name}' failed\"\n\n    def get_vocabulary_list(self) -> str:\n        \"\"\"Shows all available keywords\"\"\"\n        helper = self._get_helper()\n        vocabulary = helper.get_vocabulary()\n        vocabulary_list = sorted(list(vocabulary))\n\n        output = f\"Available keywords ({len(vocabulary_list)} total)\\n\\n\"\n        output += \", \".join(vocabulary_list)\n\n        if helper.filter_enabled and helper.filtered_types:\n            output += f\"\\n\\nFilter active: {', '.join(helper.filtered_types)} excluded\"\n\n        return output\n\n    def get_controllable_devices_summary(self) -> str:\n        \"\"\"Overview of all controllable devices\"\"\"\n        helper = self._get_helper()\n        items = helper.load_openhab_items(force_reload=True)\n\n        if not items:\n            return f\"[ERROR] Items could not be loaded: {helper.last_load_error}\"\n\n        controllable_items = [\n            item for item in items if helper.is_controllable_item(item)\n        ]\n        readonly_items = [\n            item for item in items if not helper.is_controllable_item(item)\n        ]\n\n        output = f\"Smart Home Overview\\n\\n\"\n        output += f\"Total: {len(items)} devices\\n\"\n        output += f\"Controllable: {len(controllable_items)} devices\\n\"\n        output += f\"Status only: {len(readonly_items)} devices\\n\\n\"\n\n        type_groups = {}\n        for item in controllable_items:\n            item_type = item.get(\"type\", \"Unknown\")\n            if item_type not in type_groups:\n                type_groups[item_type] = []\n            type_groups[item_type].append(item)\n\n        output += \"Controllable devices by type:\\n\"\n        for item_type, items_of_type in sorted(type_groups.items()):\n            commands = helper.get_possible_commands(items_of_type[0])\n            output += (\n                f\"- {item_type}: {len(items_of_type)} devices ({', '.join(commands)})\\n\"\n            )\n\n        output += f\"\\nTip: Use the search function to find specific devices!\"\n\n        return output\n","specs":[{"name":"_get_filtered_types","description":"Creates list of item types to filter","parameters":{"properties":{},"type":"object"}},{"name":"_get_helper","description":"Creates helper instance as needed","parameters":{"properties":{},"type":"object"}},{"name":"control_openhab_device","description":"Controls an OpenHAB device","parameters":{"properties":{"device_name":{"type":"string"},"command":{"type":"string"}},"required":["device_name","command"],"type":"object"}},{"name":"get_controllable_devices_summary","description":"Overview of all controllable devices","parameters":{"properties":{},"type":"object"}},{"name":"get_vocabulary_list","description":"Shows all available keywords","parameters":{"properties":{},"type":"object"}},{"name":"search_openhab_items","description":"Main search function for OpenHAB items with controllability info\n\nArgs:\nquery_words: List of search terms from the vocabulary\nmode: \"and\" for precise search, \"or\" for broad search\n\nReturns:\nstr: Formatted search results with controllability information","parameters":{"properties":{"query_words":{"items":{"type":"string"},"type":"array"},"mode":{"default":"and","type":"string"}},"required":["query_words"],"type":"object"}}],"meta":{"description":"OpenHAB Smart Home Integration","manifest":{"title":"OpenHAB Smart Home Tool","author":"Torsten Feustel","funding_url":"https://github.com/torfeu/openhab-ai-integration","version":"0.3.4","required_open_webui_version":"0.3.9"}},"access_control":{},"updated_at":1763281977,"created_at":1762453484}]
