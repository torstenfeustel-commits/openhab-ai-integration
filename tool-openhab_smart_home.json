[{"id":"openhab_smart_home","user_id":"230637f6-d8de-490f-8567-aa6ff543974a","name":"OpenHAB Smart Home","content":"\"\"\"\ntitle: OpenHAB Smart Home Tool v3.7 - Improved Version\nauthor: Torsten Feustel\nfunding_url: https://github.com/torfeu/openhab-ai-integration\nversion: 0.3.2\nrequired_open_webui_version: 0.3.9\n\nOpenHAB Smart Home Integration with Enhanced Error Handling\n\"\"\"\n\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, Dict, Any, List, Set\nimport requests\nimport json\nimport re\nfrom collections import defaultdict\nimport time\nimport logging\n\n\n# Logging einrichten\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass OpenHABHelper:\n    \"\"\"\n    Hilfsklasse für OpenHAB-Operationen mit verbessertem Error-Handling\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        port: str,\n        api_token: str = \"\",\n        cache_ttl: int = 3600,\n        filter_enabled: bool = True,\n        filtered_types: List[str] = None,\n    ):\n        self.host = host\n        self.port = port\n        self.api_token = api_token\n        self.cache_ttl = cache_ttl\n        self.vocabulary_cache = None\n        self.vocabulary_last_update = None\n        self.search_index = None\n        self.filter_enabled = filter_enabled\n        self.filtered_types = filtered_types or []\n        self.last_load_error = None\n        self.last_successful_load = None\n\n    def get_base_url(self) -> str:\n        \"\"\"OpenHAB Base URL erstellen\"\"\"\n        return f\"http://{self.host}:{self.port}/rest\"\n\n    def get_headers(self) -> Dict[str, str]:\n        \"\"\"HTTP Headers für OpenHAB API\"\"\"\n        headers = {\"Accept\": \"application/json\"}\n        if self.api_token:\n            headers[\"Authorization\"] = f\"Bearer {self.api_token}\"\n        return headers\n\n    def should_filter_item(self, item: Dict[str, Any]) -> bool:\n        \"\"\"Prüft ob ein Item gefiltert werden soll\"\"\"\n        if not self.filter_enabled:\n            return False\n        item_type = item.get(\"type\", \"\")\n        return item_type in self.filtered_types\n\n    def is_controllable_item(self, item: Dict[str, Any]) -> bool:\n        \"\"\"Nutzt OpenHAB's readOnly-Flag für präzise Erkennung\"\"\"\n        state_description = item.get(\"stateDescription\", {})\n        read_only = state_description.get(\"readOnly\", False)\n\n        if read_only:\n            return False\n\n        item_type = item.get(\"type\", \"\")\n        never_controllable = {\"DateTime\", \"Location\"}\n\n        if item_type in never_controllable:\n            return False\n\n        if item_type == \"Group\":\n            return False\n\n        return True\n\n    def get_possible_commands(self, item: Dict[str, Any]) -> List[str]:\n        \"\"\"Leitet aus Item-Type die möglichen Befehle ab\"\"\"\n        if not self.is_controllable_item(item):\n            return []\n\n        item_type = item.get(\"type\", \"\")\n\n        command_mapping = {\n            \"Switch\": [\"an\", \"aus\", \"toggle\"],\n            \"Dimmer\": [\"an\", \"aus\", \"0-100%\"],\n            \"Color\": [\"an\", \"aus\", \"farbe\", \"helligkeit\"],\n            \"Rollershutter\": [\"hoch\", \"runter\", \"0-100%\"],\n            \"Number:Temperature\": [\"15-30°C\"],\n            \"Number:Dimensionless\": [\"0-100\"],\n            \"Number:ElectricCurrent\": [\"stromwert\"],\n            \"Number:Power\": [\"leistungswert\"],\n            \"Number:Energy\": [\"energiewert\"],\n            \"Number:Pressure\": [\"druckwert\"],\n            \"Number:Humidity\": [\"feuchtewert\"],\n            \"Number\": [\"zahlenwert\"],\n            \"Player\": [\"play\", \"pause\", \"stop\"],\n            \"String\": [\"text\"],\n            \"Contact\": [\"status\"],\n        }\n\n        if \"Number:\" in item_type and item_type not in command_mapping:\n            return [\"zahlenwert\"]\n\n        return command_mapping.get(item_type, [\"befehl\"])\n\n    def get_control_status_text(self, item: Dict[str, Any]) -> str:\n        \"\"\"Erstellt Steuerbarkeits-Text für Ausgabe ohne Emojis\"\"\"\n        if self.is_controllable_item(item):\n            commands = self.get_possible_commands(item)\n            return f\"Steuerbar: {', '.join(commands)}\"\n        else:\n            return \"Nur Status (nicht steuerbar)\"\n\n    def load_openhab_items(self, force_reload: bool = False) -> List[Dict[str, Any]]:\n        \"\"\"\n        Lädt alle OpenHAB Items mit verbessertem Error-Handling\n\n        Args:\n            force_reload: Erzwingt Neuladen auch wenn Cache noch gültig ist\n\n        Returns:\n            Liste der Items oder leere Liste bei Fehler (mit Fehler-Logging)\n        \"\"\"\n        try:\n            response = requests.get(\n                f\"{self.get_base_url()}/items\", headers=self.get_headers(), timeout=15\n            )\n\n            if response.status_code == 200:\n                all_items = response.json()\n\n                # Validierung: Prüfe ob die Response sinnvoll ist\n                if not isinstance(all_items, list):\n                    error_msg = f\"Ungültige Response: Erwartete Liste, erhielt {type(all_items)}\"\n                    logger.error(error_msg)\n                    self.last_load_error = error_msg\n                    return []\n\n                if len(all_items) == 0:\n                    logger.warning(\n                        \"OpenHAB hat 0 Items zurückgegeben - möglicherweise ein Problem\"\n                    )\n                    self.last_load_error = \"Keine Items von OpenHAB erhalten\"\n                    return []\n\n                # Filter anwenden\n                if self.filter_enabled:\n                    filtered_items = [\n                        item for item in all_items if not self.should_filter_item(item)\n                    ]\n                    logger.info(\n                        f\"Filter aktiv: {len(all_items)} Items -> {len(filtered_items)} Items \"\n                        f\"(gefiltert: {self.filtered_types})\"\n                    )\n                    all_items = filtered_items\n                else:\n                    logger.info(f\"Filter deaktiviert: {len(all_items)} Items geladen\")\n\n                # Erfolgreicher Load\n                self.last_successful_load = time.time()\n                self.last_load_error = None\n                return all_items\n\n            else:\n                error_msg = (\n                    f\"OpenHAB API Fehler {response.status_code}: {response.text[:200]}\"\n                )\n                logger.error(error_msg)\n                self.last_load_error = error_msg\n                return []\n\n        except requests.exceptions.Timeout:\n            error_msg = f\"Timeout beim Verbinden zu OpenHAB ({self.host}:{self.port})\"\n            logger.error(error_msg)\n            self.last_load_error = error_msg\n            return []\n\n        except requests.exceptions.ConnectionError:\n            error_msg = f\"Verbindungsfehler zu OpenHAB ({self.host}:{self.port})\"\n            logger.error(error_msg)\n            self.last_load_error = error_msg\n            return []\n\n        except json.JSONDecodeError:\n            error_msg = \"OpenHAB hat ungültiges JSON zurückgegeben\"\n            logger.error(error_msg)\n            self.last_load_error = error_msg\n            return []\n\n        except Exception as e:\n            error_msg = f\"Unerwarteter Fehler beim Laden der Items: {str(e)}\"\n            logger.error(error_msg)\n            self.last_load_error = error_msg\n            return []\n\n    def extract_vocabulary(self, items_list: List[Dict[str, Any]]) -> Set[str]:\n        \"\"\"Extrahiert automatisch Schlagwörter NUR aus den aktiven (nicht gefilterten) Items\"\"\"\n        vocabulary = set()\n\n        for item in items_list:\n            if self.should_filter_item(item):\n                continue\n\n            name = item.get(\"name\", \"\")\n            if name:\n                name_parts = name.lower().split(\"_\")\n                valid_parts = [\n                    part for part in name_parts if len(part) > 2 and not part.isdigit()\n                ]\n                vocabulary.update(valid_parts)\n\n            label = item.get(\"label\", \"\")\n            if label:\n                words = re.split(r\"[^a-zA-ZäöüÄÖÜßß]+\", label.lower())\n                valid_words = [word for word in words if len(word) > 2]\n                vocabulary.update(valid_words)\n\n            state = str(item.get(\"state\", \"\")).upper()\n            if state in [\"ON\", \"OFF\", \"OPEN\", \"CLOSED\", \"NULL\", \"UNDEF\"]:\n                vocabulary.add(state.lower())\n\n            category = item.get(\"category\", \"\")\n            if category and len(category) > 2:\n                vocabulary.add(category.lower())\n\n            tags = item.get(\"tags\", [])\n            for tag in tags:\n                if isinstance(tag, str) and len(tag) > 2:\n                    vocabulary.add(tag.lower())\n\n        cleaned_vocabulary = set()\n        for word in vocabulary:\n            if len(word) > 2 and not word.isdigit():\n                cleaned_vocabulary.add(word)\n\n        return cleaned_vocabulary\n\n    def build_search_index(self, items_list: List[Dict[str, Any]]):\n        \"\"\"Erstellt einen Index für schnelle Suche\"\"\"\n        self.search_index = defaultdict(list)\n\n        for item in items_list:\n            if self.should_filter_item(item):\n                continue\n\n            name = item.get(\"name\", \"\").lower()\n            name_parts = name.split(\"_\")\n            for part in name_parts:\n                if len(part) > 2:\n                    self.search_index[part].append(item)\n\n            label = item.get(\"label\", \"\").lower()\n            if label:\n                words = re.split(r\"[^a-zA-ZäöüÄÖÜßß]+\", label)\n                for word in words:\n                    if len(word) > 2:\n                        self.search_index[word].append(item)\n\n            category = item.get(\"category\", \"\").lower()\n            if category:\n                self.search_index[category].append(item)\n\n            for tag in item.get(\"tags\", []):\n                if isinstance(tag, str):\n                    self.search_index[tag.lower()].append(item)\n\n    def check_items_changed(self, items: List[Dict[str, Any]]) -> bool:\n        \"\"\"\n        Prüft ob Items sich seit letztem Load geändert haben (basierend auf lastStateChange)\n        NEUE FUNKTION für Smart Cache Invalidation\n        \"\"\"\n        if not items:\n            return False\n\n        # Sammle alle lastStateChange Timestamps\n        max_state_change = 0\n        for item in items:\n            last_change = item.get(\"lastStateChange\", 0)\n            if isinstance(last_change, (int, float)) and last_change > max_state_change:\n                max_state_change = last_change\n\n        # Wenn wir einen alten max_state_change haben, vergleiche\n        if hasattr(self, \"last_items_max_state_change\"):\n            if max_state_change > self.last_items_max_state_change:\n                logger.info(\n                    f\"Items haben sich geändert! (max_state_change: {self.last_items_max_state_change} -> {max_state_change})\"\n                )\n                return True\n\n        # Speichere den aktuellen max_state_change\n        self.last_items_max_state_change = max_state_change\n        return False\n\n    def get_vocabulary(self, force_reload: bool = False) -> Set[str]:\n        \"\"\"Liefert das aktuelle Vokabular mit intelligentem Smart-Caching basierend auf Item-Änderungen\"\"\"\n        now = time.time()\n\n        # NEUE LOGIK: Smart Cache Invalidation\n        # 1. Prüfe ob Cache zeitlich abgelaufen ist\n        cache_age = None\n        if self.vocabulary_last_update is not None:\n            cache_age = now - self.vocabulary_last_update\n\n        # 2. Lade Items um zu prüfen ob sie sich geändert haben\n        if (\n            not force_reload\n            and self.vocabulary_cache is not None\n            and cache_age is not None\n        ):\n            # Schnelle Validierungsprüfung\n            temp_items = self.load_openhab_items(force_reload=False)\n\n            if temp_items:\n                # Prüfe ob Items sich geändert haben\n                items_changed = self.check_items_changed(temp_items)\n\n                if not items_changed and cache_age <= self.cache_ttl:\n                    logger.debug(\n                        f\"Cache gültig ({cache_age:.1f}s alt, Limit: {self.cache_ttl}s) und Items unverändert\"\n                    )\n                    return self.vocabulary_cache\n\n                if items_changed:\n                    logger.warning(\n                        f\"Cache invalidiert! Items haben sich geändert - neu laden erforderlich\"\n                    )\n                    force_reload = True\n                elif cache_age > self.cache_ttl:\n                    logger.info(\n                        f\"Cache abgelaufen ({cache_age:.1f}s > {self.cache_ttl}s) - neu laden\"\n                    )\n                    force_reload = True\n\n        # 3. Neu laden wenn nötig\n        logger.info(\"Lade Items neu...\")\n        items = self.load_openhab_items(force_reload=True)\n\n        # NEUE LOGIK: Fehlerbehandlung wenn Items nicht geladen\n        if not items and self.vocabulary_cache is not None:\n            logger.warning(\"Items konnten nicht geladen werden, verwende alten Cache\")\n            return self.vocabulary_cache\n        elif not items:\n            logger.error(\"Items konnten nicht geladen werden und kein Cache vorhanden!\")\n            return set()\n\n        # Items speichern und Cache updaten\n        self.check_items_changed(items)  # Speichere max_state_change\n        self.vocabulary_cache = self.extract_vocabulary(items)\n        self.vocabulary_last_update = now\n        self.build_search_index(items)\n\n        logger.info(f\"Vokabular aktualisiert: {len(self.vocabulary_cache)} Wörter\")\n        return self.vocabulary_cache\n\n    def normalize_umlauts(self, word: str) -> str:\n        \"\"\"Normalisiert deutsche Umlaute für OpenHAB-Kompatibilität\"\"\"\n        umlaut_map = {\n            \"ä\": \"ae\",\n            \"ö\": \"oe\",\n            \"ü\": \"ue\",\n            \"Ä\": \"AE\",\n            \"Ö\": \"OE\",\n            \"Ü\": \"UE\",\n            \"ß\": \"ss\",\n        }\n\n        if word.lower() == \"küche\":\n            return \"kueche\"\n        if word.lower() == \"tür\":\n            return \"tuer\"\n        if word.lower() == \"draußen\":\n            return \"draussen\"\n        if word.lower() == \"büro\":\n            return \"buero\"\n\n        normalized = word\n        for umlaut, replacement in umlaut_map.items():\n            normalized = normalized.replace(umlaut, replacement)\n\n        return normalized\n\n    def search_items_and(self, query_words: List[str]) -> List[Dict[str, Any]]:\n        \"\"\"UND-Suche: Items müssen ALLE Query-Wörter enthalten\"\"\"\n        if not self.search_index:\n            return []\n\n        query_words_lower = [word.lower() for word in query_words]\n\n        item_sets = []\n        for word in query_words_lower:\n            if word in self.search_index:\n                item_set = set()\n                for item in self.search_index[word]:\n                    if not self.should_filter_item(item):\n                        item_set.add(item[\"name\"])\n                item_sets.append(item_set)\n            else:\n                return []\n\n        if not item_sets:\n            return []\n\n        common_items = item_sets[0]\n        for item_set in item_sets[1:]:\n            common_items = common_items.intersection(item_set)\n\n        results = []\n        for word in query_words_lower:\n            for item in self.search_index[word]:\n                if item[\"name\"] in common_items and not self.should_filter_item(item):\n                    if not any(r[\"name\"] == item[\"name\"] for r in results):\n                        item_copy = item.copy()\n                        item_copy[\"match_score\"] = len(query_words)\n                        results.append(item_copy)\n\n        return results\n\n    def search_items_or(self, query_words: List[str]) -> List[Dict[str, Any]]:\n        \"\"\"ODER-Suche: Items müssen mindestens EIN Query-Wort enthalten\"\"\"\n        if not self.search_index:\n            return []\n\n        query_words_lower = [word.lower() for word in query_words]\n        results_dict = {}\n\n        for word in query_words_lower:\n            if word in self.search_index:\n                for item in self.search_index[word]:\n                    if self.should_filter_item(item):\n                        continue\n\n                    item_name = item[\"name\"]\n                    if item_name not in results_dict:\n                        item_copy = item.copy()\n                        item_copy[\"match_score\"] = 1\n                        item_copy[\"matched_words\"] = [word]\n                        results_dict[item_name] = item_copy\n                    else:\n                        results_dict[item_name][\"match_score\"] += 1\n                        results_dict[item_name][\"matched_words\"].append(word)\n\n        results = list(results_dict.values())\n        results.sort(key=lambda x: x[\"match_score\"], reverse=True)\n        return results\n\n    def validate_query(\n        self, query_words: List[str], search_mode: str = \"and\"\n    ) -> Dict[str, Any]:\n        \"\"\"Validiert die Suchanfrage gegen das Vokabular\"\"\"\n        if not query_words:\n            return {\"valid\": False, \"error\": \"Leere Suchanfrage\"}\n\n        if len(query_words) > 10:\n            return {\"valid\": False, \"error\": \"Zu viele Suchbegriffe (max 10)\"}\n\n        vocabulary = self.get_vocabulary()\n\n        if not vocabulary:\n            return {\n                \"valid\": False,\n                \"error\": f\"Vokabular konnte nicht geladen werden: {self.last_load_error}\",\n                \"complete_vocabulary\": [],\n            }\n\n        valid_words = [w for w in query_words if w.lower() in vocabulary]\n        invalid_words = [w for w in query_words if w.lower() not in vocabulary]\n\n        if invalid_words:\n            vocabulary_list = sorted(list(vocabulary))\n\n            if search_mode.lower() == \"and\":\n                error_msg = f\"AND-Suche gestoppt!\\n\\nUngültige Schlagwörter: {', '.join(invalid_words)}\\n\\nAND-Suche benötigt ALLE Begriffe im Vokabular.\"\n            else:\n                error_msg = (\n                    f\"Ungültige Schlagwörter gefunden: {', '.join(invalid_words)}\"\n                )\n\n            error_msg += f\"\\n\\nBitte verwenden Sie nur diese {len(vocabulary_list)} verfügbaren Schlagwörter:\"\n\n            return {\n                \"valid\": False,\n                \"error\": error_msg,\n                \"invalid_words\": invalid_words,\n                \"valid_words\": valid_words,\n                \"complete_vocabulary\": vocabulary_list,\n                \"recommend_vocabulary_check\": True,\n            }\n\n        if not valid_words:\n            vocabulary_list = sorted(list(vocabulary))\n            return {\n                \"valid\": False,\n                \"error\": \"Keine gültigen Suchbegriffe gefunden\",\n                \"complete_vocabulary\": vocabulary_list,\n                \"recommend_vocabulary_check\": True,\n            }\n\n        return {\n            \"valid\": True,\n            \"valid_words\": valid_words,\n            \"invalid_words\": invalid_words,\n        }\n\n    def get_device_icon(self, item: Dict[str, Any]) -> str:\n        \"\"\"Bestimmt Text-Indikator basierend auf Item-Typ und Namen\"\"\"\n        name = item.get(\"name\", \"\").lower()\n        label = item.get(\"label\", \"\").lower()\n        state = str(item.get(\"state\", \"\"))\n        item_type = item.get(\"type\", \"\")\n        category = item.get(\"category\", \"\").lower()\n\n        if (\n            any(x in name for x in [\"licht\", \"lampe\", \"leuchte\"])\n            or any(x in label for x in [\"licht\", \"lampe\", \"leuchte\"])\n            or \"light\" in category\n        ):\n            return (\n                \"[LICHT_AN]\"\n                if state not in [\"OFF\", \"0\", \"NULL\", \"UNDEF\"]\n                else \"[LICHT_AUS]\"\n            )\n\n        if \"temperatur\" in name or \"temperatur\" in label or \"temperature\" in item_type:\n            return \"[TEMP]\"\n\n        if \"steckdose\" in name or \"switch\" in item_type or \"switch\" in category:\n            return \"[SWITCH_ON]\" if state == \"ON\" else \"[SWITCH_OFF]\"\n\n        if (\n            any(x in name for x in [\"kontakt\", \"tuer\", \"fenster\"])\n            or \"contact\" in item_type\n        ):\n            return \"[DOOR_OPEN]\" if state == \"OPEN\" else \"[DOOR_CLOSED]\"\n\n        if \"rollo\" in name or \"rollershutter\" in item_type:\n            return \"[ROLLERSHUTTER]\"\n\n        if \"sensor\" in name or \"humidity\" in item_type or \"pressure\" in item_type:\n            if \"bewegung\" in name or \"motion\" in label:\n                return \"[MOTION]\"\n            elif any(x in name for x in [\"luftfeuchte\", \"humidity\"]):\n                return \"[HUMIDITY]\"\n            elif any(x in name for x in [\"luftdruck\", \"pressure\"]):\n                return \"[PRESSURE]\"\n            else:\n                return \"[SENSOR]\"\n\n        return \"[DEVICE]\"\n\n    def format_search_results(\n        self, results: List[Dict[str, Any]], mode: str, max_results: int = 50\n    ) -> str:\n        \"\"\"Formatiert Suchergebnisse MIT Steuerbarkeits-Informationen ohne Emojis\"\"\"\n        if not results:\n            return \"Keine Ergebnisse gefunden.\"\n\n        filter_info = \"\"\n        if self.filter_enabled and self.filtered_types:\n            filter_info = f\" | Filter: {', '.join(self.filtered_types)} ausgeschlossen\"\n\n        controllable_count = sum(\n            1 for item in results if self.is_controllable_item(item)\n        )\n        readonly_count = len(results) - controllable_count\n\n        output = f\"Suchergebnisse ({mode.upper()}-Modus, {len(results)} gefunden{filter_info})\\n\"\n        output += f\"{controllable_count} steuerbar | {readonly_count} nur Status\\n\\n\"\n\n        for item in results[:max_results]:\n            name = item.get(\"name\", \"Unbekannt\")\n            label = item.get(\"label\", name)\n            state = item.get(\"state\", \"N/A\")\n            item_type = item.get(\"type\", \"Unknown\")\n            match_score = item.get(\"match_score\", 0)\n\n            icon = self.get_device_icon(item)\n            control_indicator = (\n                \"[STEUERBAR]\" if self.is_controllable_item(item) else \"[STATUS]\"\n            )\n\n            output += f\"{icon}{control_indicator} {label} ({item_type})\\n\"\n            output += f\"   Status: {state}\"\n\n            if mode == \"or\" and \"matched_words\" in item:\n                matched = \", \".join(item[\"matched_words\"])\n                output += f\" | Match: {matched}\"\n\n            output += f\" | Score: {match_score}\\n\"\n\n            control_info = self.get_control_status_text(item)\n            output += f\"   {control_info}\\n\"\n\n            output += f\"   Name: {name}\\n\\n\"\n\n        if len(results) > max_results:\n            hidden = len(results) - max_results\n            output += f\"... und {hidden} weitere Ergebnisse\\n\"\n\n        return output\n\n    def send_command(self, device_name: str, command: str) -> bool:\n        \"\"\"Sendet Befehl an OpenHAB Gerät\"\"\"\n        try:\n            headers = self.get_headers()\n            headers[\"Content-Type\"] = \"text/plain\"\n\n            command_mapping = {\n                \"ein\": \"ON\",\n                \"an\": \"ON\",\n                \"on\": \"ON\",\n                \"aus\": \"OFF\",\n                \"off\": \"OFF\",\n                \"toggle\": \"TOGGLE\",\n                \"umschalten\": \"TOGGLE\",\n                \"hoch\": \"UP\",\n                \"up\": \"UP\",\n                \"runter\": \"DOWN\",\n                \"down\": \"DOWN\",\n            }\n\n            mapped_command = command_mapping.get(command.lower(), command)\n\n            response = requests.post(\n                f\"{self.get_base_url()}/items/{device_name}\",\n                data=mapped_command,\n                headers=headers,\n                timeout=10,\n            )\n\n            return response.status_code in [200, 202]\n\n        except Exception as e:\n            logger.error(f\"Fehler beim Senden von Befehl: {e}\")\n            return False\n\n    def clear_cache(self):\n        \"\"\"Löscht Cache manuell - nützlich für Debugging\"\"\"\n        self.vocabulary_cache = None\n        self.vocabulary_last_update = None\n        self.search_index = None\n        logger.info(\"Cache gelöscht\")\n\n    def get_cache_status(self) -> Dict[str, Any]:\n        \"\"\"Gibt Informationen über Cache-Status zurück\"\"\"\n        now = time.time()\n        cache_age = None\n\n        if self.vocabulary_last_update:\n            cache_age = now - self.vocabulary_last_update\n\n        return {\n            \"cache_valid\": self.vocabulary_cache is not None,\n            \"cache_age_seconds\": cache_age,\n            \"cache_ttl\": self.cache_ttl,\n            \"vocabulary_size\": (\n                len(self.vocabulary_cache) if self.vocabulary_cache else 0\n            ),\n            \"last_load_error\": self.last_load_error,\n            \"last_successful_load\": self.last_successful_load,\n        }\n\n\nclass Tools:\n    class Valves(BaseModel):\n        openhab_host: str = Field(\n            default=\"192.168.1.100\", description=\"OpenHAB Server IP-Adresse\"\n        )\n        openhab_port: str = Field(default=\"8080\", description=\"OpenHAB Server Port\")\n        openhab_api_token: str = Field(\n            default=\"\", description=\"OpenHAB API Token (optional)\"\n        )\n        max_search_results: int = Field(\n            default=50, description=\"Maximale Anzahl Suchergebnisse\"\n        )\n        cache_ttl: int = Field(\n            default=3600, description=\"Vokabular Cache TTL in Sekunden\"\n        )\n        enable_item_filter: bool = Field(\n            default=True, description=\"Item-Typ-Filter aktivieren\"\n        )\n        filter_group_items: bool = Field(\n            default=True, description=\"Gruppen-Items ausfiltern\"\n        )\n        custom_filtered_types: str = Field(\n            default=\"\", description=\"Zusätzliche Item-Typen filtern (kommagetrennt)\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self.helper = None\n\n    def _get_filtered_types(self) -> List[str]:\n        \"\"\"Erstellt Liste der zu filternden Item-Typen\"\"\"\n        filtered_types = []\n\n        if self.valves.filter_group_items:\n            filtered_types.append(\"Group\")\n\n        if self.valves.custom_filtered_types:\n            custom_types = [\n                t.strip() for t in self.valves.custom_filtered_types.split(\",\")\n            ]\n            filtered_types.extend(custom_types)\n\n        return filtered_types\n\n    def _get_helper(self) -> OpenHABHelper:\n        \"\"\"Erstellt Helper-Instanz bei Bedarf\"\"\"\n        filtered_types = self._get_filtered_types()\n\n        if (\n            self.helper is None\n            or self.helper.filter_enabled != self.valves.enable_item_filter\n            or self.helper.filtered_types != filtered_types\n        ):\n\n            self.helper = OpenHABHelper(\n                host=self.valves.openhab_host,\n                port=self.valves.openhab_port,\n                api_token=self.valves.openhab_api_token,\n                cache_ttl=self.valves.cache_ttl,\n                filter_enabled=self.valves.enable_item_filter,\n                filtered_types=filtered_types,\n            )\n        return self.helper\n\n    def search_openhab_items(self, query_words: List[str], mode: str = \"and\") -> str:\n        \"\"\"\n        Hauptsuchfunktion für OpenHAB Items mit Steuerbarkeits-Info\n\n        Args:\n            query_words: Liste der Suchbegriffe aus dem Vokabular\n            mode: \"and\" für präzise Suche, \"or\" für breite Suche\n\n        Returns:\n            str: Formatierte Suchergebnisse mit Steuerbarkeits-Informationen\n        \"\"\"\n        start_time = time.time()\n        helper = self._get_helper()\n\n        normalized_words = []\n        umlaut_changes = []\n\n        for word in query_words:\n            normalized = helper.normalize_umlauts(word)\n            normalized_words.append(normalized)\n\n            if normalized != word:\n                umlaut_changes.append(f\"'{word}' → '{normalized}'\")\n\n        validation = helper.validate_query(normalized_words, mode)\n        if not validation[\"valid\"]:\n            error_msg = validation[\"error\"]\n\n            if \"complete_vocabulary\" in validation:\n                vocabulary_list = validation[\"complete_vocabulary\"]\n                error_msg += (\n                    f\"\\n\\n**Alle {len(vocabulary_list)} verfügbaren Schlagwörter:**\\n\"\n                )\n                error_msg += \", \".join(vocabulary_list)\n                return error_msg\n\n            return error_msg\n\n        valid_words = validation[\"valid_words\"]\n\n        if mode.lower() == \"and\":\n            results = helper.search_items_and(valid_words)\n        else:\n            results = helper.search_items_or(valid_words)\n\n        search_time = round((time.time() - start_time) * 1000, 1)\n\n        output = \"\"\n\n        if umlaut_changes:\n            output += f\"Umlaut-Normalisierung: {', '.join(umlaut_changes)}\\n\"\n\n        output += f\"Suche: {', '.join(valid_words)} ({mode.upper()}-Modus)\\n\"\n        output += f\"Zeit: {search_time}ms\\n\\n\"\n        output += helper.format_search_results(\n            results, mode, self.valves.max_search_results\n        )\n\n        return output\n\n    def control_openhab_device(self, device_name: str, command: str) -> str:\n        \"\"\"Steuert ein OpenHAB-Gerät\"\"\"\n        helper = self._get_helper()\n        success = helper.send_command(device_name, command)\n\n        if success:\n            return f\"[ERFOLG] {device_name} erfolgreich auf '{command}' gesetzt!\"\n        else:\n            return f\"[FEHLER] Steuerung von '{device_name}' fehlgeschlagen\"\n\n    def get_vocabulary_list(self) -> str:\n        \"\"\"Zeigt alle verfügbaren Schlagwörter\"\"\"\n        helper = self._get_helper()\n        vocabulary = helper.get_vocabulary()\n        vocabulary_list = sorted(list(vocabulary))\n\n        output = f\"Verfügbare Schlagwörter ({len(vocabulary_list)} gesamt)\\n\\n\"\n        output += \", \".join(vocabulary_list)\n\n        if helper.filter_enabled and helper.filtered_types:\n            output += (\n                f\"\\n\\nFilter aktiv: {', '.join(helper.filtered_types)} ausgeschlossen\"\n            )\n\n        return output\n\n    def get_controllable_devices_summary(self) -> str:\n        \"\"\"Übersicht über alle steuerbaren Geräte\"\"\"\n        helper = self._get_helper()\n        items = helper.load_openhab_items(force_reload=True)\n\n        if not items:\n            return (\n                f\"[FEHLER] Items konnten nicht geladen werden: {helper.last_load_error}\"\n            )\n\n        controllable_items = [\n            item for item in items if helper.is_controllable_item(item)\n        ]\n        readonly_items = [\n            item for item in items if not helper.is_controllable_item(item)\n        ]\n\n        output = f\"Smart Home Übersicht\\n\\n\"\n        output += f\"Gesamt: {len(items)} Geräte\\n\"\n        output += f\"Steuerbar: {len(controllable_items)} Geräte\\n\"\n        output += f\"Nur Status: {len(readonly_items)} Geräte\\n\\n\"\n\n        type_groups = {}\n        for item in controllable_items:\n            item_type = item.get(\"type\", \"Unknown\")\n            if item_type not in type_groups:\n                type_groups[item_type] = []\n            type_groups[item_type].append(item)\n\n        output += \"Steuerbare Geräte nach Typ:\\n\"\n        for item_type, items_of_type in sorted(type_groups.items()):\n            commands = helper.get_possible_commands(items_of_type[0])\n            output += (\n                f\"- {item_type}: {len(items_of_type)} Geräte ({', '.join(commands)})\\n\"\n            )\n\n        output += (\n            f\"\\nTipp: Verwenden Sie die Suchfunktion um spezifische Geräte zu finden!\"\n        )\n\n        return output\n","specs":[{"name":"_get_filtered_types","description":"Erstellt Liste der zu filternden Item-Typen","parameters":{"properties":{},"type":"object"}},{"name":"_get_helper","description":"Erstellt Helper-Instanz bei Bedarf","parameters":{"properties":{},"type":"object"}},{"name":"control_openhab_device","description":"Steuert ein OpenHAB-Gerät","parameters":{"properties":{"device_name":{"type":"string"},"command":{"type":"string"}},"required":["device_name","command"],"type":"object"}},{"name":"get_controllable_devices_summary","description":"Übersicht über alle steuerbaren Geräte","parameters":{"properties":{},"type":"object"}},{"name":"get_vocabulary_list","description":"Zeigt alle verfügbaren Schlagwörter","parameters":{"properties":{},"type":"object"}},{"name":"search_openhab_items","description":"Hauptsuchfunktion für OpenHAB Items mit Steuerbarkeits-Info\n\nArgs:\nquery_words: Liste der Suchbegriffe aus dem Vokabular\nmode: \"and\" für präzise Suche, \"or\" für breite Suche\n\nReturns:\nstr: Formatierte Suchergebnisse mit Steuerbarkeits-Informationen","parameters":{"properties":{"query_words":{"items":{"type":"string"},"type":"array"},"mode":{"default":"and","type":"string"}},"required":["query_words"],"type":"object"}}],"meta":{"description":"OpenHAB Smart Home Integration","manifest":{"title":"OpenHAB Smart Home Tool v3.7 - Improved Version","author":"Torsten Feustel","funding_url":"https://github.com/torfeu/openhab-ai-integration","version":"0.3.2","required_open_webui_version":"0.3.9"}},"access_control":{},"updated_at":1762536054,"created_at":1762087819}]